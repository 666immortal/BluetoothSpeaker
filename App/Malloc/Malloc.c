/*********************************************************************************************************
* 模块名称: Malloc.c
* 摘    要: 
* 当前版本: 1.0.0
* 作    者: 
* 完成日期: 2018年03月01日
* 内    容:
* 注    意: none                                                                  
**********************************************************************************************************
* 取代版本: 
* 作    者:
* 完成日期: 
* 修改内容:
* 修改文件: 
*********************************************************************************************************/

/*********************************************************************************************************
*                                              包含头文件
*********************************************************************************************************/
#include "Malloc.h"      

/*********************************************************************************************************
*                                              宏定义
*********************************************************************************************************/
//定义内存表1管理范围大小
#define MEM1_ALLOC_TABLE_SIZE     USER_DEFINE_MEM1_MAX_SIZE / USER_DEFINE_MEM1_BLOCK_SIZE
//定义内存表2管理范围大小 
#define MEM2_ALLOC_TABLE_SIZE     USER_DEFINE_MEM2_MAX_SIZE / USER_DEFINE_MEM2_BLOCK_SIZE   

/*********************************************************************************************************
*                                              内部变量
*********************************************************************************************************/
//__align(32)指示编译器在32字节边界上对齐变量，即内存池中存储为32字节对齐
__align(32) u8 mem1Base[USER_DEFINE_MEM1_MAX_SIZE];                       //定义数组控制内部SRAM内存池
//定义数组控制外部SRAM内存池，变量始于地址0X68000000
__align(32) u8 mem2Base[USER_DEFINE_MEM2_MAX_SIZE] __attribute__((at(0X68000000)));  

u16 mem1MapBase[MEM1_ALLOC_TABLE_SIZE];                                   //定义数组作为内部SRAM内存管理表
//定义数组作为外部SRAM内存管理表，变量始于地址0X68000000 + MEM2_MAX_SIZE
u16 mem2MapBase[MEM2_ALLOC_TABLE_SIZE] __attribute__((at(0X68000000 + USER_DEFINE_MEM2_MAX_SIZE)));

//定义常类型数组记录内存表大小
const u32 memTblSize[USER_DEFINE_SRAMBANK] = {MEM1_ALLOC_TABLE_SIZE, MEM2_ALLOC_TABLE_SIZE};
//定义常类型数组记录内存分块大小
const u32 memBlkSize[USER_DEFINE_SRAMBANK] = {USER_DEFINE_MEM1_BLOCK_SIZE, USER_DEFINE_MEM2_BLOCK_SIZE};            
//定义常类型数组记录内存总大小
const u32 memSize[USER_DEFINE_SRAMBANK]    = {USER_DEFINE_MEM1_MAX_SIZE, USER_DEFINE_MEM2_MAX_SIZE};                

/*********************************************************************************************************
*                                              枚举结构体定义
*********************************************************************************************************/
//内存管理控制器初始化
StructMemMallocDev StructMallocDev =
{
  InitMemMgt,       //内存初始化
  GetMemPerused,    //内存使用率 
  mem1Base,         //内部SRAM内存池
  mem2Base,         //外部SRAM内存池 
  mem1MapBase,      //内部SRAM内存管理表
  mem2MapBase,      //外部SRAM内存管理表 
  0,                //0表示内存管理未就绪
  0,                 
};

/*********************************************************************************************************
*                                              内部函数声明
*********************************************************************************************************/
static void SetMem(void* s, u8 c, u32 count);          //设置内存
static void CopyMem(void* des, void* src, u32 n);      //复制内存     
static u32  MallocMemInw(u8 memx, u32 size);           //内存分配(内部调用)
static u8   FreeMemInw(u8 memx, u32 offset);           //内存释放(内部调用)

/*********************************************************************************************************
*                                              内部函数实现
*********************************************************************************************************/
/*********************************************************************************************************
* 函数名称: CopyMem
* 函数功能: 复制内存
* 输入参数: *des:目的地址，*src:源地址，n:需要复制的内存长度(字节为单位)
* 输出参数: void
* 返 回 值: void
* 创建日期: 2018年03月01日
* 注    意:
*********************************************************************************************************/
static void CopyMem(void* des, void* src, u32 n)  
{                        
  u8* xDes = des;        //定义u8类型的指针变量xDes，记录复制到的目的地址
  u8* xSrc = src;        //定义u8类型的指针变量xSrc，记录复制的源地址
                         
  while(n--)             //没复制完成
  {                      
    *xDes++ = *xSrc++;   //目的地址、源地址各加1，再次复制下一个字节
  }  
}  

/*********************************************************************************************************
* 函数名称: SetMem
* 函数功能: 设置内存
* 输入参数: *s:内存首地址，c :要设置的值，count:需要设置的内存大小(字节为单位)
* 输出参数: void
* 返 回 值: void
* 创建日期: 2018年03月01日
* 注    意:
*********************************************************************************************************/
static void SetMem(void* s, u8 c, u32 count)  
{  
    u8* xS = s;          //定义u8类型的指针变量xS，记录内存首地址  
                         
    while(count--)       //没设置完需要设置的内存大小
    {                    
      *xS++ = c;         //要设置的内存地址加1，继续设置预设值
    }
}     

/*********************************************************************************************************
* 函数名称: MallocMemInw
* 函数功能: 内存分配(内部调用)
* 输入参数: memx:所属内存块，size:要分配的内存大小(字节)
* 输出参数: void
* 返 回 值: 0XFFFFFFFF,代表错误;其他,内存偏移地址 
* 创建日期: 2018年03月01日
* 注    意:
*********************************************************************************************************/
u32 MallocMemInw(u8 memx, u32 size)  
{  
  signed long offset = 0;//定义变量，记录内存位置  
  u32 nMemb;             //定义变量，记录需要的内存块数  
  u32 cMemb = 0;         //定义变量，记录连续空内存块数
  u32 i;                 //定义变量，作为循环计数器
  
  if(!StructMallocDev.memReady[memx]) //内存管理未就绪，未初始化完成
  {
    StructMallocDev.init(memx);       //执行初始化 
  }
  if(size == 0)                       //不需要分配内存
  {
    return 0XFFFFFFFF;                //返回表示操作错误
  }
  
  nMemb = size / memBlkSize[memx];    //获取需要分配的连续内存块数
  
  if(size % memBlkSize[memx])         //要求分配的内存大小不为内存块大小的整数倍
  {
    nMemb++;                          //追加分配内存块
  }
  
  for(offset = memTblSize[memx] - 1; offset >= 0; offset--)//搜索整个内存控制区  
  {     
    if(!StructMallocDev.memMap[memx][offset])              //内存块对应位置为空
    {
      cMemb++;                                             //连续空内存块数增加
    }
    else                                                   //内存块对应位置不为空
    {
      cMemb = 0;                                           //连续空内存块数清零
    }
    
    if(cMemb == nMemb)                                     //找到了nMemb个连续空内存块
    {      
      for(i = 0; i < nMemb; i++)                           //对找出的符合要求的内存块进行操作
      {         
        StructMallocDev.memMap[memx][offset + i] = nMemb;  //从偏移地址开始标注对应内存管理表内容  
      }  
         
      return (offset * memBlkSize[memx]);                  //返回内存位置即偏移地址  
    }    
  }  
  
  return 0XFFFFFFFF;                                       //未找到符合分配条件的内存块  
}  

/*********************************************************************************************************
* 函数名称: FreeMemInw
* 函数功能: 释放内存(内部调用)
* 输入参数: memx:所属内存块，offset:内存偏移地址
* 输出参数: void
* 返 回 值: 0,释放成功;1,释放失败;2，偏移超区
* 创建日期: 2018年03月01日
* 注    意:
*********************************************************************************************************/
u8 FreeMemInw(u8 memx, u32 offset)  
{  
  int i;                                //定义变量，作为循环计数器
  
  if(!StructMallocDev.memReady[memx])   //内存管理未就绪，未初始化完成
  {
    StructMallocDev.init(memx);         //执行初始化 
    
    return 1;                           //返回1表示释放失败    
  }  
   
  if(offset < memSize[memx])            //地址偏移在内存池范围内 
  {     
    int inDex = offset / memBlkSize[memx];            //定义变量，记录偏移所在内存块号码    
    int nMemb = StructMallocDev.memMap[memx][inDex];  //定义变量，记录内存块数量    
    
    for(i = 0; i < nMemb; i++)                        //循环直至所有内存块清零      
    {             
      StructMallocDev.memMap[memx][inDex + i] = 0;    //对应的内存表清零   
    }        
    
    return 0;                                         //返回0表示释放成功
  }
  else 
  {
    return 2;                                         //放回2表示偏移超区了.  
  }
}  

/*********************************************************************************************************
*                                              API函数实现
*********************************************************************************************************/
/*********************************************************************************************************
* 函数名称: InitMemMgt
* 函数功能: 内存管理初始化
* 输入参数: memx:所属内存块
* 输出参数: void
* 返 回 值: void
* 创建日期: 2018年03月01日
* 注    意:
*********************************************************************************************************/
void InitMemMgt(u8 memx)  
{  
  SetMem(StructMallocDev.memMap[memx], 0, memTblSize[memx] * 2);     //内存状态表数据清零  
  SetMem(StructMallocDev.memBase[memx], 0, memSize[memx]);           //内存池所有数据清零  
  StructMallocDev.memReady[memx] = 1;                                //设置值为1，内存管理初始化完成
}  

/*********************************************************************************************************
* 函数名称: GetMemPerused
* 函数功能: 获取内存使用率
* 输入参数: memx:所属内存块
* 输出参数: void
* 返 回 值: 使用率(0~100)
* 创建日期: 2018年03月01日
* 注    意:
*********************************************************************************************************/
u8 GetMemPerused(u8 memx)  
{  
  u32 used = 0;                            //定义u32类型的变量used，记录内存的使用数
  u32 i;                                   //定义u32类型的变量i，作为循环计数器
    
  for(i = 0; i < memTblSize[memx]; i++)    //循环直至查询到所有内存位置 
  {  
    if(StructMallocDev.memMap[memx][i])    //内存该位置已使用
    {
      used++;                              //内存的使用数加1
    }
  } 
    
  return (used * 100) / (memTblSize[memx]);//返回内存使用率  
}  


/*********************************************************************************************************
* 函数名称: FreeMemExt
* 函数功能: 释放内存(外部调用)
* 输入参数: memx:所属内存块，ptr:内存首地址
* 输出参数: void
* 返 回 值: void 
* 创建日期: 2018年03月01日
* 注    意:
*********************************************************************************************************/
void FreeMemExt(u8 memx, void* ptr)  
{  
  u32 offset;                                             //定义变量，记录内存偏移地址
                                                          
  if(ptr == NULL)                                         //内存首地址为空
  {                                                       
    return;                                               //结束操作
   }

  offset = (u32)ptr - (u32)StructMallocDev.memBase[memx]; //获取内存偏移地址    
    
  FreeMemInw(memx, offset);                               //释放内存      
}  

/*********************************************************************************************************
* 函数名称: MallocMemExt
* 函数功能: 释放内存(外部调用)
* 输入参数: memx:所属内存块，size:内存大小(字节)
* 输出参数: void*
* 返 回 值: 分配到的内存首地址 
* 创建日期: 2018年03月01日
* 注    意:
*********************************************************************************************************/
void* MallocMemExt(u8 memx,u32 size)  
{  
  u32 offset;                         //定义变量，记录内存偏移地址
  
  offset = MallocMemInw(memx, size);  //获取内存偏移地址              
   
  if(offset == 0XFFFFFFFF)            //发生错误
  {
    return NULL;                      //返回为空
  } 
  else                                //正常
  {
    return (void*)((u32)StructMallocDev.memBase[memx] + offset); //返回内存块地址 加上偏移地址即内存首地址
  }
}  

/*********************************************************************************************************
* 函数名称: ReallocMemExt
* 函数功能: 重新分配内存(外部调用)
* 输入参数: memx:所属内存块，*ptr:旧内存首地址，size:要分配的内存大小(字节)
* 输出参数: void*
* 返 回 值: 新分配到的内存首地址
* 创建日期: 2018年03月01日
* 注    意:
*********************************************************************************************************/
void* ReallocMemExt(u8 memx, void* ptr, u32 size)  
{  
    u32 offset;                        //定义变量，记录内存偏移地址
  
    offset = MallocMemInw(memx,size);  //获取内存偏移地址 
   
    if(offset == 0XFFFFFFFF)           //发生错误
    {
      return NULL;                     //返回为空
    }
    else                               //正常
    {                       
      CopyMem((void*)((u32)StructMallocDev.memBase[memx] + offset), ptr, size);  //拷贝旧内存内容到新内存           
      FreeMemExt(memx, ptr);                                                     //释放旧内存
        
      return (void*)((u32)StructMallocDev.memBase[memx] + offset);               //返回新内存首地址
    }  
}
